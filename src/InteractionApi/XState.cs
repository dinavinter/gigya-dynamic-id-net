// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var xState = XState.FromJson(jsonString);

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Globalization;
using System.Text.Json.Serialization;


    public partial class XState
    {
        [JsonPropertyName("context")] public Dictionary<string, object> Context { get; set; }

        [JsonPropertyName("entry")] public object[] Entry { get; set; }

        [JsonPropertyName("exit")] public object[] Exit { get; set; }

        [JsonPropertyName("id")] public string Id { get; set; }

        [JsonPropertyName("initial")] public string Initial { get; set; }

        [JsonPropertyName("invoke")] public InvokeObject[] Invoke { get; set; }

        [JsonPropertyName("key")] public string Key { get; set; }

        [JsonPropertyName("on")] public Dictionary<string, TransitionObject[]> On { get; set; }

        [JsonPropertyName("order")] public long? Order { get; set; }

        [JsonPropertyName("states")] public Dictionary<string, BaseStateNode> States { get; set; }

        [JsonPropertyName("transitions")] public TransitionObject[] Transitions { get; set; }

        [JsonPropertyName("type")] public TypeEnum Type { get; set; }

        [JsonPropertyName("version")] public string Version { get; set; }
    }

    public class InvokeObject
    {
        [JsonPropertyName("autoForward")] public bool? AutoForward { get; set; }

        [JsonPropertyName("id")] public string Id { get; set; }

        [JsonPropertyName("src")] public Src Src { get; set; }

        [JsonPropertyName("type")] public string Type { get; set; }
    }

    public class Src
    {
        [JsonPropertyName("type")] public string Type { get; set; }
    }

        public class TransitionObject
        {
            [JsonPropertyName("actions")] public ActionObject[] Actions { get; set; }

            [JsonPropertyName("cond")] public Dictionary<string, object> Cond { get; set; }

            [JsonPropertyName("eventType")] public string EventType { get; set; }

            [JsonPropertyName("source")] public string Source { get; set; }

            [JsonPropertyName("target")] public string[] Target { get; set; }
        }

    public partial class CompoundStateNode
    {
        /// <summary>
        /// The description of the state node, in Markdown
        /// </summary>
        public string Description { get; set; }

        public string Id { get; set; }
        public string Key { get; set; }
        public long? Order { get; set; }
        public StateNodeType Type { get; set; }
        public ActionObject[] Entry { get; set; }
        public ActionObject[] Exit { get; set; }
        public string Initial { get; set; }
        public InvokeObject[] Invoke { get; set; }
        public Dictionary<string, object> On { get; set; }
        public StatesObject States { get; set; }
    }

    public partial class StatesObject
    {

        public AtomicStateNode Atomic { get; set; }
        public CompoundStateNode Compound { get; set; }
        public FinalStateNode Final { get; set; }
        public HistoryStateNode History { get; set; }
        public AtomicStateNode Parallel { get; set; }
    }
public partial class StateNode
{
    /// <summary>
    /// The description of the state node, in Markdown
    /// </summary>
    public string Description { get; set; }

    public string Id { get; set; }
    public string Key { get; set; }
    public long? Order { get; set; }
    public StateNodeType Type { get; set; }


    public AtomicStateNode Atomic { get; set; }
    public CompoundStateNode Compound { get; set; }
    public FinalStateNode Final { get; set; }
    public HistoryStateNode History { get; set; }
    public AtomicStateNode Parallel { get; set; }
}

public  class BaseStateNode
{
    /// <summary>
    /// The description of the state node, in Markdown
    /// </summary>
    public string Description { get; set; }

    public string Id { get; set; }
    public string Key { get; set; }
    public long? Order { get; set; }
    public StateNodeType Type { get; set; }
    public ActionObject[] Entry { get; set; }
    public ActionObject[] Exit { get; set; }
    public InvokeObject[] Invoke { get; set; }
    public Dictionary<string, TransitionObject[]> On { get; set; }
}

    public   class AtomicStateNode
    {
        /// <summary>
        /// The description of the state node, in Markdown
        /// </summary>
        public string Description { get; set; }

        public string Id { get; set; }
        public string Key { get; set; }
        public long? Order { get; set; }
        public StateNodeType Type { get; set; }
        public ActionObject[] Entry { get; set; }
        public ActionObject[] Exit { get; set; }
        public InvokeObject[] Invoke { get; set; }
        public Dictionary<string, TransitionObject> On { get; set; }
    }

    public   class FinalStateNode
    {
        /// <summary>
        /// The description of the state node, in Markdown
        /// </summary>
        public string Description { get; set; }

        public string Id { get; set; }
        public string Key { get; set; }
        public long? Order { get; set; }
        public StateNodeType Type { get; set; }
        public Dictionary<string, object> Data { get; set; }
    }

    public   class HistoryStateNode
    {
        /// <summary>
        /// The description of the state node, in Markdown
        /// </summary>
        public string Description { get; set; }

        public string Id { get; set; }
        public string Key { get; set; }
        public long? Order { get; set; }
        public StateNodeType Type { get; set; }
        public History History { get; set; }


    }





    public class ActionObject
    {
        [JsonPropertyName("type")] public string Type { get; set; }
    }


    public partial class XState
    {
        public static XState FromJson(string json) => JsonSerializer.Deserialize<XState>(json, Converter.Settings);
        public static XState FromJson(JsonDocument json) => JsonSerializer.Deserialize<XState>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this XState self) => JsonSerializer.Serialize(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerOptions? Settings = new JsonSerializerOptions
        {
            WriteIndented = false,
            IgnoreNullValues = true,
            PropertyNameCaseInsensitive = false,
            ReadCommentHandling = JsonCommentHandling.Skip,
            Converters =
            {
                new TypeEnumConverter()
            },
        };
    }

    public class TypeEnumConverter : JsonConverter<TypeEnum>
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override TypeEnum Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            if (reader.TokenType == JsonTokenType.String)
            {
                var stringValue = reader.GetString();
                switch (stringValue)
                {
                    case "compound":
                        return TypeEnum.Compound;
                    case "parallel":
                        return TypeEnum.Parallel;
                }
            }


            throw new JsonException("Cannot unmarshal type TypeEnum");
        }

        public override void Write(Utf8JsonWriter writer, TypeEnum value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case TypeEnum.Compound:
                    writer.WriteStringValue("compound");
                    break;
                case TypeEnum.Parallel:
                    writer.WriteStringValue("parallel");
                    break;
                default:
                    writer.WriteStringValue(value.ToString().ToLower());
                    break;
            }
        }
    }
public enum StateNodeType { Atomic, Compound, Final, History, Parallel };
public enum History { Deep, Shallow };
public enum TypeEnum
{
    Compound,
    Parallel
};
